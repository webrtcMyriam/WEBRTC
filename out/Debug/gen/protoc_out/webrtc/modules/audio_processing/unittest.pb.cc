// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: unittest.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "unittest.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace webrtc {
namespace audioproc {

void protobuf_ShutdownFile_unittest_2eproto() {
  delete Test::default_instance_;
  delete Test_Frame::default_instance_;
  delete Test_Statistic::default_instance_;
  delete Test_EchoMetrics::default_instance_;
  delete Test_DelayMetrics::default_instance_;
  delete OutputData::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_unittest_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_unittest_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Test::default_instance_ = new Test();
  Test_Frame::default_instance_ = new Test_Frame();
  Test_Statistic::default_instance_ = new Test_Statistic();
  Test_EchoMetrics::default_instance_ = new Test_EchoMetrics();
  Test_DelayMetrics::default_instance_ = new Test_DelayMetrics();
  OutputData::default_instance_ = new OutputData();
  Test::default_instance_->InitAsDefaultInstance();
  Test_Frame::default_instance_->InitAsDefaultInstance();
  Test_Statistic::default_instance_->InitAsDefaultInstance();
  Test_EchoMetrics::default_instance_->InitAsDefaultInstance();
  Test_DelayMetrics::default_instance_->InitAsDefaultInstance();
  OutputData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_unittest_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_unittest_2eproto_once_);
void protobuf_AddDesc_unittest_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_unittest_2eproto_once_,
                 &protobuf_AddDesc_unittest_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_unittest_2eproto {
  StaticDescriptorInitializer_unittest_2eproto() {
    protobuf_AddDesc_unittest_2eproto();
  }
} static_descriptor_initializer_unittest_2eproto_;
#endif

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForTest(
    Test* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForTest_Frame(
    Test_Frame* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Test_Frame::Test_Frame()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.Test.Frame)
}

void Test_Frame::InitAsDefaultInstance() {
}

Test_Frame::Test_Frame(const Test_Frame& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.Test.Frame)
}

void Test_Frame::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test_Frame::~Test_Frame() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.Test.Frame)
  SharedDtor();
}

void Test_Frame::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Test_Frame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test_Frame& Test_Frame::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_unittest_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_unittest_2eproto();
#endif
  return *default_instance_;
}

Test_Frame* Test_Frame::default_instance_ = NULL;

Test_Frame* Test_Frame::New(::google::protobuf::Arena* arena) const {
  Test_Frame* n = new Test_Frame;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Test_Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.Test.Frame)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Test_Frame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTest_Frame, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.Test.Frame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.Test.Frame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.Test.Frame)
  return false;
#undef DO_
}

void Test_Frame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.Test.Frame)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.Test.Frame)
}

int Test_Frame::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.Test.Frame)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test_Frame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_Frame*>(&from));
}

void Test_Frame::MergeFrom(const Test_Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.Test.Frame)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Test_Frame::CopyFrom(const Test_Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.Test.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_Frame::IsInitialized() const {

  return true;
}

void Test_Frame::Swap(Test_Frame* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Test_Frame::InternalSwap(Test_Frame* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Test_Frame::GetTypeName() const {
  return "webrtc.audioproc.Test.Frame";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTest_Statistic(
    Test_Statistic* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Test_Statistic::kInstantFieldNumber;
const int Test_Statistic::kAverageFieldNumber;
const int Test_Statistic::kMaximumFieldNumber;
const int Test_Statistic::kMinimumFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Test_Statistic::Test_Statistic()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.Test.Statistic)
}

void Test_Statistic::InitAsDefaultInstance() {
}

Test_Statistic::Test_Statistic(const Test_Statistic& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.Test.Statistic)
}

void Test_Statistic::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  instant_ = 0;
  average_ = 0;
  maximum_ = 0;
  minimum_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test_Statistic::~Test_Statistic() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.Test.Statistic)
  SharedDtor();
}

void Test_Statistic::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Test_Statistic::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test_Statistic& Test_Statistic::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_unittest_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_unittest_2eproto();
#endif
  return *default_instance_;
}

Test_Statistic* Test_Statistic::default_instance_ = NULL;

Test_Statistic* Test_Statistic::New(::google::protobuf::Arena* arena) const {
  Test_Statistic* n = new Test_Statistic;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Test_Statistic::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.Test.Statistic)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Test_Statistic, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Test_Statistic*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(instant_, minimum_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Test_Statistic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTest_Statistic, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.Test.Statistic)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 instant = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &instant_)));
          set_has_instant();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_average;
        break;
      }

      // optional int32 average = 2;
      case 2: {
        if (tag == 16) {
         parse_average:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &average_)));
          set_has_average();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_maximum;
        break;
      }

      // optional int32 maximum = 3;
      case 3: {
        if (tag == 24) {
         parse_maximum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maximum_)));
          set_has_maximum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_minimum;
        break;
      }

      // optional int32 minimum = 4;
      case 4: {
        if (tag == 32) {
         parse_minimum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minimum_)));
          set_has_minimum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.Test.Statistic)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.Test.Statistic)
  return false;
#undef DO_
}

void Test_Statistic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.Test.Statistic)
  // optional int32 instant = 1;
  if (has_instant()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->instant(), output);
  }

  // optional int32 average = 2;
  if (has_average()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->average(), output);
  }

  // optional int32 maximum = 3;
  if (has_maximum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->maximum(), output);
  }

  // optional int32 minimum = 4;
  if (has_minimum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->minimum(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.Test.Statistic)
}

int Test_Statistic::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.Test.Statistic)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional int32 instant = 1;
    if (has_instant()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->instant());
    }

    // optional int32 average = 2;
    if (has_average()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->average());
    }

    // optional int32 maximum = 3;
    if (has_maximum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maximum());
    }

    // optional int32 minimum = 4;
    if (has_minimum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->minimum());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test_Statistic::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_Statistic*>(&from));
}

void Test_Statistic::MergeFrom(const Test_Statistic& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.Test.Statistic)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_instant()) {
      set_instant(from.instant());
    }
    if (from.has_average()) {
      set_average(from.average());
    }
    if (from.has_maximum()) {
      set_maximum(from.maximum());
    }
    if (from.has_minimum()) {
      set_minimum(from.minimum());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Test_Statistic::CopyFrom(const Test_Statistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.Test.Statistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_Statistic::IsInitialized() const {

  return true;
}

void Test_Statistic::Swap(Test_Statistic* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Test_Statistic::InternalSwap(Test_Statistic* other) {
  std::swap(instant_, other->instant_);
  std::swap(average_, other->average_);
  std::swap(maximum_, other->maximum_);
  std::swap(minimum_, other->minimum_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Test_Statistic::GetTypeName() const {
  return "webrtc.audioproc.Test.Statistic";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTest_EchoMetrics(
    Test_EchoMetrics* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Test_EchoMetrics::kResidualEchoReturnLossFieldNumber;
const int Test_EchoMetrics::kEchoReturnLossFieldNumber;
const int Test_EchoMetrics::kEchoReturnLossEnhancementFieldNumber;
const int Test_EchoMetrics::kANlpFieldNumber;
const int Test_EchoMetrics::kDivergentFilterFractionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Test_EchoMetrics::Test_EchoMetrics()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.Test.EchoMetrics)
}

void Test_EchoMetrics::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  residual_echo_return_loss_ = const_cast< ::webrtc::audioproc::Test_Statistic*>(
      ::webrtc::audioproc::Test_Statistic::internal_default_instance());
#else
  residual_echo_return_loss_ = const_cast< ::webrtc::audioproc::Test_Statistic*>(&::webrtc::audioproc::Test_Statistic::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  echo_return_loss_ = const_cast< ::webrtc::audioproc::Test_Statistic*>(
      ::webrtc::audioproc::Test_Statistic::internal_default_instance());
#else
  echo_return_loss_ = const_cast< ::webrtc::audioproc::Test_Statistic*>(&::webrtc::audioproc::Test_Statistic::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  echo_return_loss_enhancement_ = const_cast< ::webrtc::audioproc::Test_Statistic*>(
      ::webrtc::audioproc::Test_Statistic::internal_default_instance());
#else
  echo_return_loss_enhancement_ = const_cast< ::webrtc::audioproc::Test_Statistic*>(&::webrtc::audioproc::Test_Statistic::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  a_nlp_ = const_cast< ::webrtc::audioproc::Test_Statistic*>(
      ::webrtc::audioproc::Test_Statistic::internal_default_instance());
#else
  a_nlp_ = const_cast< ::webrtc::audioproc::Test_Statistic*>(&::webrtc::audioproc::Test_Statistic::default_instance());
#endif
}

Test_EchoMetrics::Test_EchoMetrics(const Test_EchoMetrics& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.Test.EchoMetrics)
}

void Test_EchoMetrics::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  residual_echo_return_loss_ = NULL;
  echo_return_loss_ = NULL;
  echo_return_loss_enhancement_ = NULL;
  a_nlp_ = NULL;
  divergent_filter_fraction_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test_EchoMetrics::~Test_EchoMetrics() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.Test.EchoMetrics)
  SharedDtor();
}

void Test_EchoMetrics::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete residual_echo_return_loss_;
    delete echo_return_loss_;
    delete echo_return_loss_enhancement_;
    delete a_nlp_;
  }
}

void Test_EchoMetrics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test_EchoMetrics& Test_EchoMetrics::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_unittest_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_unittest_2eproto();
#endif
  return *default_instance_;
}

Test_EchoMetrics* Test_EchoMetrics::default_instance_ = NULL;

Test_EchoMetrics* Test_EchoMetrics::New(::google::protobuf::Arena* arena) const {
  Test_EchoMetrics* n = new Test_EchoMetrics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Test_EchoMetrics::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.Test.EchoMetrics)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_residual_echo_return_loss()) {
      if (residual_echo_return_loss_ != NULL) residual_echo_return_loss_->::webrtc::audioproc::Test_Statistic::Clear();
    }
    if (has_echo_return_loss()) {
      if (echo_return_loss_ != NULL) echo_return_loss_->::webrtc::audioproc::Test_Statistic::Clear();
    }
    if (has_echo_return_loss_enhancement()) {
      if (echo_return_loss_enhancement_ != NULL) echo_return_loss_enhancement_->::webrtc::audioproc::Test_Statistic::Clear();
    }
    if (has_a_nlp()) {
      if (a_nlp_ != NULL) a_nlp_->::webrtc::audioproc::Test_Statistic::Clear();
    }
    divergent_filter_fraction_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Test_EchoMetrics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTest_EchoMetrics, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.Test.EchoMetrics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .webrtc.audioproc.Test.Statistic residual_echo_return_loss = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_residual_echo_return_loss()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_echo_return_loss;
        break;
      }

      // optional .webrtc.audioproc.Test.Statistic echo_return_loss = 2;
      case 2: {
        if (tag == 18) {
         parse_echo_return_loss:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_echo_return_loss()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_echo_return_loss_enhancement;
        break;
      }

      // optional .webrtc.audioproc.Test.Statistic echo_return_loss_enhancement = 3;
      case 3: {
        if (tag == 26) {
         parse_echo_return_loss_enhancement:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_echo_return_loss_enhancement()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_a_nlp;
        break;
      }

      // optional .webrtc.audioproc.Test.Statistic a_nlp = 4;
      case 4: {
        if (tag == 34) {
         parse_a_nlp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_a_nlp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_divergent_filter_fraction;
        break;
      }

      // optional float divergent_filter_fraction = 5;
      case 5: {
        if (tag == 45) {
         parse_divergent_filter_fraction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &divergent_filter_fraction_)));
          set_has_divergent_filter_fraction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.Test.EchoMetrics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.Test.EchoMetrics)
  return false;
#undef DO_
}

void Test_EchoMetrics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.Test.EchoMetrics)
  // optional .webrtc.audioproc.Test.Statistic residual_echo_return_loss = 1;
  if (has_residual_echo_return_loss()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->residual_echo_return_loss_, output);
  }

  // optional .webrtc.audioproc.Test.Statistic echo_return_loss = 2;
  if (has_echo_return_loss()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->echo_return_loss_, output);
  }

  // optional .webrtc.audioproc.Test.Statistic echo_return_loss_enhancement = 3;
  if (has_echo_return_loss_enhancement()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->echo_return_loss_enhancement_, output);
  }

  // optional .webrtc.audioproc.Test.Statistic a_nlp = 4;
  if (has_a_nlp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->a_nlp_, output);
  }

  // optional float divergent_filter_fraction = 5;
  if (has_divergent_filter_fraction()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->divergent_filter_fraction(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.Test.EchoMetrics)
}

int Test_EchoMetrics::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.Test.EchoMetrics)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional .webrtc.audioproc.Test.Statistic residual_echo_return_loss = 1;
    if (has_residual_echo_return_loss()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->residual_echo_return_loss_);
    }

    // optional .webrtc.audioproc.Test.Statistic echo_return_loss = 2;
    if (has_echo_return_loss()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->echo_return_loss_);
    }

    // optional .webrtc.audioproc.Test.Statistic echo_return_loss_enhancement = 3;
    if (has_echo_return_loss_enhancement()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->echo_return_loss_enhancement_);
    }

    // optional .webrtc.audioproc.Test.Statistic a_nlp = 4;
    if (has_a_nlp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->a_nlp_);
    }

    // optional float divergent_filter_fraction = 5;
    if (has_divergent_filter_fraction()) {
      total_size += 1 + 4;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test_EchoMetrics::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_EchoMetrics*>(&from));
}

void Test_EchoMetrics::MergeFrom(const Test_EchoMetrics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.Test.EchoMetrics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_residual_echo_return_loss()) {
      mutable_residual_echo_return_loss()->::webrtc::audioproc::Test_Statistic::MergeFrom(from.residual_echo_return_loss());
    }
    if (from.has_echo_return_loss()) {
      mutable_echo_return_loss()->::webrtc::audioproc::Test_Statistic::MergeFrom(from.echo_return_loss());
    }
    if (from.has_echo_return_loss_enhancement()) {
      mutable_echo_return_loss_enhancement()->::webrtc::audioproc::Test_Statistic::MergeFrom(from.echo_return_loss_enhancement());
    }
    if (from.has_a_nlp()) {
      mutable_a_nlp()->::webrtc::audioproc::Test_Statistic::MergeFrom(from.a_nlp());
    }
    if (from.has_divergent_filter_fraction()) {
      set_divergent_filter_fraction(from.divergent_filter_fraction());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Test_EchoMetrics::CopyFrom(const Test_EchoMetrics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.Test.EchoMetrics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_EchoMetrics::IsInitialized() const {

  return true;
}

void Test_EchoMetrics::Swap(Test_EchoMetrics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Test_EchoMetrics::InternalSwap(Test_EchoMetrics* other) {
  std::swap(residual_echo_return_loss_, other->residual_echo_return_loss_);
  std::swap(echo_return_loss_, other->echo_return_loss_);
  std::swap(echo_return_loss_enhancement_, other->echo_return_loss_enhancement_);
  std::swap(a_nlp_, other->a_nlp_);
  std::swap(divergent_filter_fraction_, other->divergent_filter_fraction_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Test_EchoMetrics::GetTypeName() const {
  return "webrtc.audioproc.Test.EchoMetrics";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTest_DelayMetrics(
    Test_DelayMetrics* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Test_DelayMetrics::kMedianFieldNumber;
const int Test_DelayMetrics::kStdFieldNumber;
const int Test_DelayMetrics::kFractionPoorDelaysFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Test_DelayMetrics::Test_DelayMetrics()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.Test.DelayMetrics)
}

void Test_DelayMetrics::InitAsDefaultInstance() {
}

Test_DelayMetrics::Test_DelayMetrics(const Test_DelayMetrics& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.Test.DelayMetrics)
}

void Test_DelayMetrics::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  median_ = 0;
  std_ = 0;
  fraction_poor_delays_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test_DelayMetrics::~Test_DelayMetrics() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.Test.DelayMetrics)
  SharedDtor();
}

void Test_DelayMetrics::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Test_DelayMetrics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test_DelayMetrics& Test_DelayMetrics::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_unittest_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_unittest_2eproto();
#endif
  return *default_instance_;
}

Test_DelayMetrics* Test_DelayMetrics::default_instance_ = NULL;

Test_DelayMetrics* Test_DelayMetrics::New(::google::protobuf::Arena* arena) const {
  Test_DelayMetrics* n = new Test_DelayMetrics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Test_DelayMetrics::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.Test.DelayMetrics)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Test_DelayMetrics, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Test_DelayMetrics*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(median_, fraction_poor_delays_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Test_DelayMetrics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTest_DelayMetrics, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.Test.DelayMetrics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 median = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &median_)));
          set_has_median();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_std;
        break;
      }

      // optional int32 std = 2;
      case 2: {
        if (tag == 16) {
         parse_std:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &std_)));
          set_has_std();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_fraction_poor_delays;
        break;
      }

      // optional float fraction_poor_delays = 3;
      case 3: {
        if (tag == 29) {
         parse_fraction_poor_delays:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fraction_poor_delays_)));
          set_has_fraction_poor_delays();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.Test.DelayMetrics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.Test.DelayMetrics)
  return false;
#undef DO_
}

void Test_DelayMetrics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.Test.DelayMetrics)
  // optional int32 median = 1;
  if (has_median()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->median(), output);
  }

  // optional int32 std = 2;
  if (has_std()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->std(), output);
  }

  // optional float fraction_poor_delays = 3;
  if (has_fraction_poor_delays()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->fraction_poor_delays(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.Test.DelayMetrics)
}

int Test_DelayMetrics::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.Test.DelayMetrics)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional int32 median = 1;
    if (has_median()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->median());
    }

    // optional int32 std = 2;
    if (has_std()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->std());
    }

    // optional float fraction_poor_delays = 3;
    if (has_fraction_poor_delays()) {
      total_size += 1 + 4;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test_DelayMetrics::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_DelayMetrics*>(&from));
}

void Test_DelayMetrics::MergeFrom(const Test_DelayMetrics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.Test.DelayMetrics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_median()) {
      set_median(from.median());
    }
    if (from.has_std()) {
      set_std(from.std());
    }
    if (from.has_fraction_poor_delays()) {
      set_fraction_poor_delays(from.fraction_poor_delays());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Test_DelayMetrics::CopyFrom(const Test_DelayMetrics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.Test.DelayMetrics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_DelayMetrics::IsInitialized() const {

  return true;
}

void Test_DelayMetrics::Swap(Test_DelayMetrics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Test_DelayMetrics::InternalSwap(Test_DelayMetrics* other) {
  std::swap(median_, other->median_);
  std::swap(std_, other->std_);
  std::swap(fraction_poor_delays_, other->fraction_poor_delays_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Test_DelayMetrics::GetTypeName() const {
  return "webrtc.audioproc.Test.DelayMetrics";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Test::kNumReverseChannelsFieldNumber;
const int Test::kNumInputChannelsFieldNumber;
const int Test::kNumOutputChannelsFieldNumber;
const int Test::kSampleRateFieldNumber;
const int Test::kFrameFieldNumber;
const int Test::kAnalogLevelAverageFieldNumber;
const int Test::kMaxOutputAverageFieldNumber;
const int Test::kHasEchoCountFieldNumber;
const int Test::kHasVoiceCountFieldNumber;
const int Test::kIsSaturatedCountFieldNumber;
const int Test::kEchoMetricsFieldNumber;
const int Test::kDelayMetricsFieldNumber;
const int Test::kRmsLevelFieldNumber;
const int Test::kNsSpeechProbabilityAverageFieldNumber;
const int Test::kUseAecExtendedFilterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Test::Test()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.Test)
}

void Test::InitAsDefaultInstance() {
}

Test::Test(const Test& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.Test)
}

void Test::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  num_reverse_channels_ = 0;
  num_input_channels_ = 0;
  num_output_channels_ = 0;
  sample_rate_ = 0;
  analog_level_average_ = 0;
  max_output_average_ = 0;
  has_echo_count_ = 0;
  has_voice_count_ = 0;
  is_saturated_count_ = 0;
  ns_speech_probability_average_ = 0;
  use_aec_extended_filter_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test::~Test() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.Test)
  SharedDtor();
}

void Test::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Test::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test& Test::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_unittest_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_unittest_2eproto();
#endif
  return *default_instance_;
}

Test* Test::default_instance_ = NULL;

Test* Test::New(::google::protobuf::Arena* arena) const {
  Test* n = new Test;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Test::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.Test)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Test, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Test*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 239u) {
    ZR_(num_reverse_channels_, sample_rate_);
    ZR_(analog_level_average_, has_echo_count_);
  }
  if (_has_bits_[8 / 32] & 25344u) {
    ZR_(is_saturated_count_, ns_speech_probability_average_);
    has_voice_count_ = 0;
    use_aec_extended_filter_ = false;
  }

#undef ZR_HELPER_
#undef ZR_

  frame_.Clear();
  echo_metrics_.Clear();
  delay_metrics_.Clear();
  rms_level_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Test::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.Test)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 num_reverse_channels = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_reverse_channels_)));
          set_has_num_reverse_channels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_num_input_channels;
        break;
      }

      // optional int32 num_input_channels = 2;
      case 2: {
        if (tag == 16) {
         parse_num_input_channels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_input_channels_)));
          set_has_num_input_channels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_num_output_channels;
        break;
      }

      // optional int32 num_output_channels = 3;
      case 3: {
        if (tag == 24) {
         parse_num_output_channels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_output_channels_)));
          set_has_num_output_channels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_sample_rate;
        break;
      }

      // optional int32 sample_rate = 4;
      case 4: {
        if (tag == 32) {
         parse_sample_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sample_rate_)));
          set_has_sample_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_frame;
        break;
      }

      // repeated .webrtc.audioproc.Test.Frame frame = 5;
      case 5: {
        if (tag == 42) {
         parse_frame:
          DO_(input->IncrementRecursionDepth());
         parse_loop_frame:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_frame()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_frame;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(48)) goto parse_analog_level_average;
        break;
      }

      // optional int32 analog_level_average = 6;
      case 6: {
        if (tag == 48) {
         parse_analog_level_average:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &analog_level_average_)));
          set_has_analog_level_average();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_max_output_average;
        break;
      }

      // optional int32 max_output_average = 7;
      case 7: {
        if (tag == 56) {
         parse_max_output_average:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_output_average_)));
          set_has_max_output_average();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_has_echo_count;
        break;
      }

      // optional int32 has_echo_count = 8;
      case 8: {
        if (tag == 64) {
         parse_has_echo_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &has_echo_count_)));
          set_has_has_echo_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_has_voice_count;
        break;
      }

      // optional int32 has_voice_count = 9;
      case 9: {
        if (tag == 72) {
         parse_has_voice_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &has_voice_count_)));
          set_has_has_voice_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_is_saturated_count;
        break;
      }

      // optional int32 is_saturated_count = 10;
      case 10: {
        if (tag == 80) {
         parse_is_saturated_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_saturated_count_)));
          set_has_is_saturated_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_echo_metrics;
        break;
      }

      // repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
      case 11: {
        if (tag == 90) {
         parse_echo_metrics:
          DO_(input->IncrementRecursionDepth());
         parse_loop_echo_metrics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_echo_metrics()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_loop_echo_metrics;
        if (input->ExpectTag(98)) goto parse_loop_delay_metrics;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
      case 12: {
        if (tag == 98) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_delay_metrics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_delay_metrics()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_loop_delay_metrics;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(104)) goto parse_rms_level;
        break;
      }

      // repeated int32 rms_level = 13;
      case 13: {
        if (tag == 104) {
         parse_rms_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 104, input, this->mutable_rms_level())));
        } else if (tag == 106) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_rms_level())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_rms_level;
        if (input->ExpectTag(117)) goto parse_ns_speech_probability_average;
        break;
      }

      // optional float ns_speech_probability_average = 14;
      case 14: {
        if (tag == 117) {
         parse_ns_speech_probability_average:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ns_speech_probability_average_)));
          set_has_ns_speech_probability_average();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_use_aec_extended_filter;
        break;
      }

      // optional bool use_aec_extended_filter = 15;
      case 15: {
        if (tag == 120) {
         parse_use_aec_extended_filter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_aec_extended_filter_)));
          set_has_use_aec_extended_filter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.Test)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.Test)
  return false;
#undef DO_
}

void Test::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.Test)
  // optional int32 num_reverse_channels = 1;
  if (has_num_reverse_channels()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->num_reverse_channels(), output);
  }

  // optional int32 num_input_channels = 2;
  if (has_num_input_channels()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num_input_channels(), output);
  }

  // optional int32 num_output_channels = 3;
  if (has_num_output_channels()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num_output_channels(), output);
  }

  // optional int32 sample_rate = 4;
  if (has_sample_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->sample_rate(), output);
  }

  // repeated .webrtc.audioproc.Test.Frame frame = 5;
  for (unsigned int i = 0, n = this->frame_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->frame(i), output);
  }

  // optional int32 analog_level_average = 6;
  if (has_analog_level_average()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->analog_level_average(), output);
  }

  // optional int32 max_output_average = 7;
  if (has_max_output_average()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->max_output_average(), output);
  }

  // optional int32 has_echo_count = 8;
  if (has_has_echo_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->has_echo_count(), output);
  }

  // optional int32 has_voice_count = 9;
  if (has_has_voice_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->has_voice_count(), output);
  }

  // optional int32 is_saturated_count = 10;
  if (has_is_saturated_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->is_saturated_count(), output);
  }

  // repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
  for (unsigned int i = 0, n = this->echo_metrics_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->echo_metrics(i), output);
  }

  // repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
  for (unsigned int i = 0, n = this->delay_metrics_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, this->delay_metrics(i), output);
  }

  // repeated int32 rms_level = 13;
  for (int i = 0; i < this->rms_level_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      13, this->rms_level(i), output);
  }

  // optional float ns_speech_probability_average = 14;
  if (has_ns_speech_probability_average()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->ns_speech_probability_average(), output);
  }

  // optional bool use_aec_extended_filter = 15;
  if (has_use_aec_extended_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->use_aec_extended_filter(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.Test)
}

int Test::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.Test)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 239u) {
    // optional int32 num_reverse_channels = 1;
    if (has_num_reverse_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_reverse_channels());
    }

    // optional int32 num_input_channels = 2;
    if (has_num_input_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_input_channels());
    }

    // optional int32 num_output_channels = 3;
    if (has_num_output_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_output_channels());
    }

    // optional int32 sample_rate = 4;
    if (has_sample_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sample_rate());
    }

    // optional int32 analog_level_average = 6;
    if (has_analog_level_average()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->analog_level_average());
    }

    // optional int32 max_output_average = 7;
    if (has_max_output_average()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_output_average());
    }

    // optional int32 has_echo_count = 8;
    if (has_has_echo_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->has_echo_count());
    }

  }
  if (_has_bits_[8 / 32] & 25344u) {
    // optional int32 has_voice_count = 9;
    if (has_has_voice_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->has_voice_count());
    }

    // optional int32 is_saturated_count = 10;
    if (has_is_saturated_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->is_saturated_count());
    }

    // optional float ns_speech_probability_average = 14;
    if (has_ns_speech_probability_average()) {
      total_size += 1 + 4;
    }

    // optional bool use_aec_extended_filter = 15;
    if (has_use_aec_extended_filter()) {
      total_size += 1 + 1;
    }

  }
  // repeated .webrtc.audioproc.Test.Frame frame = 5;
  total_size += 1 * this->frame_size();
  for (int i = 0; i < this->frame_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frame(i));
  }

  // repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
  total_size += 1 * this->echo_metrics_size();
  for (int i = 0; i < this->echo_metrics_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->echo_metrics(i));
  }

  // repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
  total_size += 1 * this->delay_metrics_size();
  for (int i = 0; i < this->delay_metrics_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->delay_metrics(i));
  }

  // repeated int32 rms_level = 13;
  {
    int data_size = 0;
    for (int i = 0; i < this->rms_level_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->rms_level(i));
    }
    total_size += 1 * this->rms_level_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test*>(&from));
}

void Test::MergeFrom(const Test& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.Test)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  frame_.MergeFrom(from.frame_);
  echo_metrics_.MergeFrom(from.echo_metrics_);
  delay_metrics_.MergeFrom(from.delay_metrics_);
  rms_level_.MergeFrom(from.rms_level_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_num_reverse_channels()) {
      set_num_reverse_channels(from.num_reverse_channels());
    }
    if (from.has_num_input_channels()) {
      set_num_input_channels(from.num_input_channels());
    }
    if (from.has_num_output_channels()) {
      set_num_output_channels(from.num_output_channels());
    }
    if (from.has_sample_rate()) {
      set_sample_rate(from.sample_rate());
    }
    if (from.has_analog_level_average()) {
      set_analog_level_average(from.analog_level_average());
    }
    if (from.has_max_output_average()) {
      set_max_output_average(from.max_output_average());
    }
    if (from.has_has_echo_count()) {
      set_has_echo_count(from.has_echo_count());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_has_voice_count()) {
      set_has_voice_count(from.has_voice_count());
    }
    if (from.has_is_saturated_count()) {
      set_is_saturated_count(from.is_saturated_count());
    }
    if (from.has_ns_speech_probability_average()) {
      set_ns_speech_probability_average(from.ns_speech_probability_average());
    }
    if (from.has_use_aec_extended_filter()) {
      set_use_aec_extended_filter(from.use_aec_extended_filter());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Test::CopyFrom(const Test& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.Test)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test::IsInitialized() const {

  return true;
}

void Test::Swap(Test* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Test::InternalSwap(Test* other) {
  std::swap(num_reverse_channels_, other->num_reverse_channels_);
  std::swap(num_input_channels_, other->num_input_channels_);
  std::swap(num_output_channels_, other->num_output_channels_);
  std::swap(sample_rate_, other->sample_rate_);
  frame_.UnsafeArenaSwap(&other->frame_);
  std::swap(analog_level_average_, other->analog_level_average_);
  std::swap(max_output_average_, other->max_output_average_);
  std::swap(has_echo_count_, other->has_echo_count_);
  std::swap(has_voice_count_, other->has_voice_count_);
  std::swap(is_saturated_count_, other->is_saturated_count_);
  echo_metrics_.UnsafeArenaSwap(&other->echo_metrics_);
  delay_metrics_.UnsafeArenaSwap(&other->delay_metrics_);
  rms_level_.UnsafeArenaSwap(&other->rms_level_);
  std::swap(ns_speech_probability_average_, other->ns_speech_probability_average_);
  std::swap(use_aec_extended_filter_, other->use_aec_extended_filter_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Test::GetTypeName() const {
  return "webrtc.audioproc.Test";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Test_Frame

// -------------------------------------------------------------------

// Test_Statistic

// optional int32 instant = 1;
bool Test_Statistic::has_instant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Test_Statistic::set_has_instant() {
  _has_bits_[0] |= 0x00000001u;
}
void Test_Statistic::clear_has_instant() {
  _has_bits_[0] &= ~0x00000001u;
}
void Test_Statistic::clear_instant() {
  instant_ = 0;
  clear_has_instant();
}
 ::google::protobuf::int32 Test_Statistic::instant() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.Statistic.instant)
  return instant_;
}
 void Test_Statistic::set_instant(::google::protobuf::int32 value) {
  set_has_instant();
  instant_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.Statistic.instant)
}

// optional int32 average = 2;
bool Test_Statistic::has_average() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Test_Statistic::set_has_average() {
  _has_bits_[0] |= 0x00000002u;
}
void Test_Statistic::clear_has_average() {
  _has_bits_[0] &= ~0x00000002u;
}
void Test_Statistic::clear_average() {
  average_ = 0;
  clear_has_average();
}
 ::google::protobuf::int32 Test_Statistic::average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.Statistic.average)
  return average_;
}
 void Test_Statistic::set_average(::google::protobuf::int32 value) {
  set_has_average();
  average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.Statistic.average)
}

// optional int32 maximum = 3;
bool Test_Statistic::has_maximum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Test_Statistic::set_has_maximum() {
  _has_bits_[0] |= 0x00000004u;
}
void Test_Statistic::clear_has_maximum() {
  _has_bits_[0] &= ~0x00000004u;
}
void Test_Statistic::clear_maximum() {
  maximum_ = 0;
  clear_has_maximum();
}
 ::google::protobuf::int32 Test_Statistic::maximum() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.Statistic.maximum)
  return maximum_;
}
 void Test_Statistic::set_maximum(::google::protobuf::int32 value) {
  set_has_maximum();
  maximum_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.Statistic.maximum)
}

// optional int32 minimum = 4;
bool Test_Statistic::has_minimum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Test_Statistic::set_has_minimum() {
  _has_bits_[0] |= 0x00000008u;
}
void Test_Statistic::clear_has_minimum() {
  _has_bits_[0] &= ~0x00000008u;
}
void Test_Statistic::clear_minimum() {
  minimum_ = 0;
  clear_has_minimum();
}
 ::google::protobuf::int32 Test_Statistic::minimum() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.Statistic.minimum)
  return minimum_;
}
 void Test_Statistic::set_minimum(::google::protobuf::int32 value) {
  set_has_minimum();
  minimum_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.Statistic.minimum)
}

// -------------------------------------------------------------------

// Test_EchoMetrics

// optional .webrtc.audioproc.Test.Statistic residual_echo_return_loss = 1;
bool Test_EchoMetrics::has_residual_echo_return_loss() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Test_EchoMetrics::set_has_residual_echo_return_loss() {
  _has_bits_[0] |= 0x00000001u;
}
void Test_EchoMetrics::clear_has_residual_echo_return_loss() {
  _has_bits_[0] &= ~0x00000001u;
}
void Test_EchoMetrics::clear_residual_echo_return_loss() {
  if (residual_echo_return_loss_ != NULL) residual_echo_return_loss_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_residual_echo_return_loss();
}
const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::residual_echo_return_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.residual_echo_return_loss)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return residual_echo_return_loss_ != NULL ? *residual_echo_return_loss_ : *default_instance().residual_echo_return_loss_;
#else
  return residual_echo_return_loss_ != NULL ? *residual_echo_return_loss_ : *default_instance_->residual_echo_return_loss_;
#endif
}
::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_residual_echo_return_loss() {
  set_has_residual_echo_return_loss();
  if (residual_echo_return_loss_ == NULL) {
    residual_echo_return_loss_ = new ::webrtc::audioproc::Test_Statistic;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.EchoMetrics.residual_echo_return_loss)
  return residual_echo_return_loss_;
}
::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_residual_echo_return_loss() {
  // @@protoc_insertion_point(field_release:webrtc.audioproc.Test.EchoMetrics.residual_echo_return_loss)
  clear_has_residual_echo_return_loss();
  ::webrtc::audioproc::Test_Statistic* temp = residual_echo_return_loss_;
  residual_echo_return_loss_ = NULL;
  return temp;
}
void Test_EchoMetrics::set_allocated_residual_echo_return_loss(::webrtc::audioproc::Test_Statistic* residual_echo_return_loss) {
  delete residual_echo_return_loss_;
  residual_echo_return_loss_ = residual_echo_return_loss;
  if (residual_echo_return_loss) {
    set_has_residual_echo_return_loss();
  } else {
    clear_has_residual_echo_return_loss();
  }
  // @@protoc_insertion_point(field_set_allocated:webrtc.audioproc.Test.EchoMetrics.residual_echo_return_loss)
}

// optional .webrtc.audioproc.Test.Statistic echo_return_loss = 2;
bool Test_EchoMetrics::has_echo_return_loss() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Test_EchoMetrics::set_has_echo_return_loss() {
  _has_bits_[0] |= 0x00000002u;
}
void Test_EchoMetrics::clear_has_echo_return_loss() {
  _has_bits_[0] &= ~0x00000002u;
}
void Test_EchoMetrics::clear_echo_return_loss() {
  if (echo_return_loss_ != NULL) echo_return_loss_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_echo_return_loss();
}
const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::echo_return_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return echo_return_loss_ != NULL ? *echo_return_loss_ : *default_instance().echo_return_loss_;
#else
  return echo_return_loss_ != NULL ? *echo_return_loss_ : *default_instance_->echo_return_loss_;
#endif
}
::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_echo_return_loss() {
  set_has_echo_return_loss();
  if (echo_return_loss_ == NULL) {
    echo_return_loss_ = new ::webrtc::audioproc::Test_Statistic;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
  return echo_return_loss_;
}
::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_echo_return_loss() {
  // @@protoc_insertion_point(field_release:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
  clear_has_echo_return_loss();
  ::webrtc::audioproc::Test_Statistic* temp = echo_return_loss_;
  echo_return_loss_ = NULL;
  return temp;
}
void Test_EchoMetrics::set_allocated_echo_return_loss(::webrtc::audioproc::Test_Statistic* echo_return_loss) {
  delete echo_return_loss_;
  echo_return_loss_ = echo_return_loss;
  if (echo_return_loss) {
    set_has_echo_return_loss();
  } else {
    clear_has_echo_return_loss();
  }
  // @@protoc_insertion_point(field_set_allocated:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
}

// optional .webrtc.audioproc.Test.Statistic echo_return_loss_enhancement = 3;
bool Test_EchoMetrics::has_echo_return_loss_enhancement() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Test_EchoMetrics::set_has_echo_return_loss_enhancement() {
  _has_bits_[0] |= 0x00000004u;
}
void Test_EchoMetrics::clear_has_echo_return_loss_enhancement() {
  _has_bits_[0] &= ~0x00000004u;
}
void Test_EchoMetrics::clear_echo_return_loss_enhancement() {
  if (echo_return_loss_enhancement_ != NULL) echo_return_loss_enhancement_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_echo_return_loss_enhancement();
}
const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::echo_return_loss_enhancement() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return echo_return_loss_enhancement_ != NULL ? *echo_return_loss_enhancement_ : *default_instance().echo_return_loss_enhancement_;
#else
  return echo_return_loss_enhancement_ != NULL ? *echo_return_loss_enhancement_ : *default_instance_->echo_return_loss_enhancement_;
#endif
}
::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_echo_return_loss_enhancement() {
  set_has_echo_return_loss_enhancement();
  if (echo_return_loss_enhancement_ == NULL) {
    echo_return_loss_enhancement_ = new ::webrtc::audioproc::Test_Statistic;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
  return echo_return_loss_enhancement_;
}
::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_echo_return_loss_enhancement() {
  // @@protoc_insertion_point(field_release:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
  clear_has_echo_return_loss_enhancement();
  ::webrtc::audioproc::Test_Statistic* temp = echo_return_loss_enhancement_;
  echo_return_loss_enhancement_ = NULL;
  return temp;
}
void Test_EchoMetrics::set_allocated_echo_return_loss_enhancement(::webrtc::audioproc::Test_Statistic* echo_return_loss_enhancement) {
  delete echo_return_loss_enhancement_;
  echo_return_loss_enhancement_ = echo_return_loss_enhancement;
  if (echo_return_loss_enhancement) {
    set_has_echo_return_loss_enhancement();
  } else {
    clear_has_echo_return_loss_enhancement();
  }
  // @@protoc_insertion_point(field_set_allocated:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
}

// optional .webrtc.audioproc.Test.Statistic a_nlp = 4;
bool Test_EchoMetrics::has_a_nlp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Test_EchoMetrics::set_has_a_nlp() {
  _has_bits_[0] |= 0x00000008u;
}
void Test_EchoMetrics::clear_has_a_nlp() {
  _has_bits_[0] &= ~0x00000008u;
}
void Test_EchoMetrics::clear_a_nlp() {
  if (a_nlp_ != NULL) a_nlp_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_a_nlp();
}
const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::a_nlp() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.a_nlp)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return a_nlp_ != NULL ? *a_nlp_ : *default_instance().a_nlp_;
#else
  return a_nlp_ != NULL ? *a_nlp_ : *default_instance_->a_nlp_;
#endif
}
::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_a_nlp() {
  set_has_a_nlp();
  if (a_nlp_ == NULL) {
    a_nlp_ = new ::webrtc::audioproc::Test_Statistic;
  }
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.EchoMetrics.a_nlp)
  return a_nlp_;
}
::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_a_nlp() {
  // @@protoc_insertion_point(field_release:webrtc.audioproc.Test.EchoMetrics.a_nlp)
  clear_has_a_nlp();
  ::webrtc::audioproc::Test_Statistic* temp = a_nlp_;
  a_nlp_ = NULL;
  return temp;
}
void Test_EchoMetrics::set_allocated_a_nlp(::webrtc::audioproc::Test_Statistic* a_nlp) {
  delete a_nlp_;
  a_nlp_ = a_nlp;
  if (a_nlp) {
    set_has_a_nlp();
  } else {
    clear_has_a_nlp();
  }
  // @@protoc_insertion_point(field_set_allocated:webrtc.audioproc.Test.EchoMetrics.a_nlp)
}

// optional float divergent_filter_fraction = 5;
bool Test_EchoMetrics::has_divergent_filter_fraction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Test_EchoMetrics::set_has_divergent_filter_fraction() {
  _has_bits_[0] |= 0x00000010u;
}
void Test_EchoMetrics::clear_has_divergent_filter_fraction() {
  _has_bits_[0] &= ~0x00000010u;
}
void Test_EchoMetrics::clear_divergent_filter_fraction() {
  divergent_filter_fraction_ = 0;
  clear_has_divergent_filter_fraction();
}
 float Test_EchoMetrics::divergent_filter_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.divergent_filter_fraction)
  return divergent_filter_fraction_;
}
 void Test_EchoMetrics::set_divergent_filter_fraction(float value) {
  set_has_divergent_filter_fraction();
  divergent_filter_fraction_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.divergent_filter_fraction)
}

// -------------------------------------------------------------------

// Test_DelayMetrics

// optional int32 median = 1;
bool Test_DelayMetrics::has_median() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Test_DelayMetrics::set_has_median() {
  _has_bits_[0] |= 0x00000001u;
}
void Test_DelayMetrics::clear_has_median() {
  _has_bits_[0] &= ~0x00000001u;
}
void Test_DelayMetrics::clear_median() {
  median_ = 0;
  clear_has_median();
}
 ::google::protobuf::int32 Test_DelayMetrics::median() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.DelayMetrics.median)
  return median_;
}
 void Test_DelayMetrics::set_median(::google::protobuf::int32 value) {
  set_has_median();
  median_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.DelayMetrics.median)
}

// optional int32 std = 2;
bool Test_DelayMetrics::has_std() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Test_DelayMetrics::set_has_std() {
  _has_bits_[0] |= 0x00000002u;
}
void Test_DelayMetrics::clear_has_std() {
  _has_bits_[0] &= ~0x00000002u;
}
void Test_DelayMetrics::clear_std() {
  std_ = 0;
  clear_has_std();
}
 ::google::protobuf::int32 Test_DelayMetrics::std() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.DelayMetrics.std)
  return std_;
}
 void Test_DelayMetrics::set_std(::google::protobuf::int32 value) {
  set_has_std();
  std_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.DelayMetrics.std)
}

// optional float fraction_poor_delays = 3;
bool Test_DelayMetrics::has_fraction_poor_delays() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Test_DelayMetrics::set_has_fraction_poor_delays() {
  _has_bits_[0] |= 0x00000004u;
}
void Test_DelayMetrics::clear_has_fraction_poor_delays() {
  _has_bits_[0] &= ~0x00000004u;
}
void Test_DelayMetrics::clear_fraction_poor_delays() {
  fraction_poor_delays_ = 0;
  clear_has_fraction_poor_delays();
}
 float Test_DelayMetrics::fraction_poor_delays() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.DelayMetrics.fraction_poor_delays)
  return fraction_poor_delays_;
}
 void Test_DelayMetrics::set_fraction_poor_delays(float value) {
  set_has_fraction_poor_delays();
  fraction_poor_delays_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.DelayMetrics.fraction_poor_delays)
}

// -------------------------------------------------------------------

// Test

// optional int32 num_reverse_channels = 1;
bool Test::has_num_reverse_channels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Test::set_has_num_reverse_channels() {
  _has_bits_[0] |= 0x00000001u;
}
void Test::clear_has_num_reverse_channels() {
  _has_bits_[0] &= ~0x00000001u;
}
void Test::clear_num_reverse_channels() {
  num_reverse_channels_ = 0;
  clear_has_num_reverse_channels();
}
 ::google::protobuf::int32 Test::num_reverse_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_reverse_channels)
  return num_reverse_channels_;
}
 void Test::set_num_reverse_channels(::google::protobuf::int32 value) {
  set_has_num_reverse_channels();
  num_reverse_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_reverse_channels)
}

// optional int32 num_input_channels = 2;
bool Test::has_num_input_channels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Test::set_has_num_input_channels() {
  _has_bits_[0] |= 0x00000002u;
}
void Test::clear_has_num_input_channels() {
  _has_bits_[0] &= ~0x00000002u;
}
void Test::clear_num_input_channels() {
  num_input_channels_ = 0;
  clear_has_num_input_channels();
}
 ::google::protobuf::int32 Test::num_input_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_input_channels)
  return num_input_channels_;
}
 void Test::set_num_input_channels(::google::protobuf::int32 value) {
  set_has_num_input_channels();
  num_input_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_input_channels)
}

// optional int32 num_output_channels = 3;
bool Test::has_num_output_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Test::set_has_num_output_channels() {
  _has_bits_[0] |= 0x00000004u;
}
void Test::clear_has_num_output_channels() {
  _has_bits_[0] &= ~0x00000004u;
}
void Test::clear_num_output_channels() {
  num_output_channels_ = 0;
  clear_has_num_output_channels();
}
 ::google::protobuf::int32 Test::num_output_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_output_channels)
  return num_output_channels_;
}
 void Test::set_num_output_channels(::google::protobuf::int32 value) {
  set_has_num_output_channels();
  num_output_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_output_channels)
}

// optional int32 sample_rate = 4;
bool Test::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Test::set_has_sample_rate() {
  _has_bits_[0] |= 0x00000008u;
}
void Test::clear_has_sample_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
void Test::clear_sample_rate() {
  sample_rate_ = 0;
  clear_has_sample_rate();
}
 ::google::protobuf::int32 Test::sample_rate() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.sample_rate)
  return sample_rate_;
}
 void Test::set_sample_rate(::google::protobuf::int32 value) {
  set_has_sample_rate();
  sample_rate_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.sample_rate)
}

// repeated .webrtc.audioproc.Test.Frame frame = 5;
int Test::frame_size() const {
  return frame_.size();
}
void Test::clear_frame() {
  frame_.Clear();
}
const ::webrtc::audioproc::Test_Frame& Test::frame(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.frame)
  return frame_.Get(index);
}
::webrtc::audioproc::Test_Frame* Test::mutable_frame(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.frame)
  return frame_.Mutable(index);
}
::webrtc::audioproc::Test_Frame* Test::add_frame() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.frame)
  return frame_.Add();
}
::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >*
Test::mutable_frame() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.frame)
  return &frame_;
}
const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >&
Test::frame() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.frame)
  return frame_;
}

// optional int32 analog_level_average = 6;
bool Test::has_analog_level_average() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Test::set_has_analog_level_average() {
  _has_bits_[0] |= 0x00000020u;
}
void Test::clear_has_analog_level_average() {
  _has_bits_[0] &= ~0x00000020u;
}
void Test::clear_analog_level_average() {
  analog_level_average_ = 0;
  clear_has_analog_level_average();
}
 ::google::protobuf::int32 Test::analog_level_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.analog_level_average)
  return analog_level_average_;
}
 void Test::set_analog_level_average(::google::protobuf::int32 value) {
  set_has_analog_level_average();
  analog_level_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.analog_level_average)
}

// optional int32 max_output_average = 7;
bool Test::has_max_output_average() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Test::set_has_max_output_average() {
  _has_bits_[0] |= 0x00000040u;
}
void Test::clear_has_max_output_average() {
  _has_bits_[0] &= ~0x00000040u;
}
void Test::clear_max_output_average() {
  max_output_average_ = 0;
  clear_has_max_output_average();
}
 ::google::protobuf::int32 Test::max_output_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.max_output_average)
  return max_output_average_;
}
 void Test::set_max_output_average(::google::protobuf::int32 value) {
  set_has_max_output_average();
  max_output_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.max_output_average)
}

// optional int32 has_echo_count = 8;
bool Test::has_has_echo_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Test::set_has_has_echo_count() {
  _has_bits_[0] |= 0x00000080u;
}
void Test::clear_has_has_echo_count() {
  _has_bits_[0] &= ~0x00000080u;
}
void Test::clear_has_echo_count() {
  has_echo_count_ = 0;
  clear_has_has_echo_count();
}
 ::google::protobuf::int32 Test::has_echo_count() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.has_echo_count)
  return has_echo_count_;
}
 void Test::set_has_echo_count(::google::protobuf::int32 value) {
  set_has_has_echo_count();
  has_echo_count_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.has_echo_count)
}

// optional int32 has_voice_count = 9;
bool Test::has_has_voice_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Test::set_has_has_voice_count() {
  _has_bits_[0] |= 0x00000100u;
}
void Test::clear_has_has_voice_count() {
  _has_bits_[0] &= ~0x00000100u;
}
void Test::clear_has_voice_count() {
  has_voice_count_ = 0;
  clear_has_has_voice_count();
}
 ::google::protobuf::int32 Test::has_voice_count() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.has_voice_count)
  return has_voice_count_;
}
 void Test::set_has_voice_count(::google::protobuf::int32 value) {
  set_has_has_voice_count();
  has_voice_count_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.has_voice_count)
}

// optional int32 is_saturated_count = 10;
bool Test::has_is_saturated_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Test::set_has_is_saturated_count() {
  _has_bits_[0] |= 0x00000200u;
}
void Test::clear_has_is_saturated_count() {
  _has_bits_[0] &= ~0x00000200u;
}
void Test::clear_is_saturated_count() {
  is_saturated_count_ = 0;
  clear_has_is_saturated_count();
}
 ::google::protobuf::int32 Test::is_saturated_count() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.is_saturated_count)
  return is_saturated_count_;
}
 void Test::set_is_saturated_count(::google::protobuf::int32 value) {
  set_has_is_saturated_count();
  is_saturated_count_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.is_saturated_count)
}

// repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
int Test::echo_metrics_size() const {
  return echo_metrics_.size();
}
void Test::clear_echo_metrics() {
  echo_metrics_.Clear();
}
const ::webrtc::audioproc::Test_EchoMetrics& Test::echo_metrics(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Get(index);
}
::webrtc::audioproc::Test_EchoMetrics* Test::mutable_echo_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Mutable(index);
}
::webrtc::audioproc::Test_EchoMetrics* Test::add_echo_metrics() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Add();
}
::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >*
Test::mutable_echo_metrics() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.echo_metrics)
  return &echo_metrics_;
}
const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >&
Test::echo_metrics() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_;
}

// repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
int Test::delay_metrics_size() const {
  return delay_metrics_.size();
}
void Test::clear_delay_metrics() {
  delay_metrics_.Clear();
}
const ::webrtc::audioproc::Test_DelayMetrics& Test::delay_metrics(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Get(index);
}
::webrtc::audioproc::Test_DelayMetrics* Test::mutable_delay_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Mutable(index);
}
::webrtc::audioproc::Test_DelayMetrics* Test::add_delay_metrics() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Add();
}
::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >*
Test::mutable_delay_metrics() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.delay_metrics)
  return &delay_metrics_;
}
const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >&
Test::delay_metrics() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_;
}

// repeated int32 rms_level = 13;
int Test::rms_level_size() const {
  return rms_level_.size();
}
void Test::clear_rms_level() {
  rms_level_.Clear();
}
 ::google::protobuf::int32 Test::rms_level(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.rms_level)
  return rms_level_.Get(index);
}
 void Test::set_rms_level(int index, ::google::protobuf::int32 value) {
  rms_level_.Set(index, value);
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.rms_level)
}
 void Test::add_rms_level(::google::protobuf::int32 value) {
  rms_level_.Add(value);
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.rms_level)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Test::rms_level() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.rms_level)
  return rms_level_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Test::mutable_rms_level() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.rms_level)
  return &rms_level_;
}

// optional float ns_speech_probability_average = 14;
bool Test::has_ns_speech_probability_average() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void Test::set_has_ns_speech_probability_average() {
  _has_bits_[0] |= 0x00002000u;
}
void Test::clear_has_ns_speech_probability_average() {
  _has_bits_[0] &= ~0x00002000u;
}
void Test::clear_ns_speech_probability_average() {
  ns_speech_probability_average_ = 0;
  clear_has_ns_speech_probability_average();
}
 float Test::ns_speech_probability_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.ns_speech_probability_average)
  return ns_speech_probability_average_;
}
 void Test::set_ns_speech_probability_average(float value) {
  set_has_ns_speech_probability_average();
  ns_speech_probability_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.ns_speech_probability_average)
}

// optional bool use_aec_extended_filter = 15;
bool Test::has_use_aec_extended_filter() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void Test::set_has_use_aec_extended_filter() {
  _has_bits_[0] |= 0x00004000u;
}
void Test::clear_has_use_aec_extended_filter() {
  _has_bits_[0] &= ~0x00004000u;
}
void Test::clear_use_aec_extended_filter() {
  use_aec_extended_filter_ = false;
  clear_has_use_aec_extended_filter();
}
 bool Test::use_aec_extended_filter() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.use_aec_extended_filter)
  return use_aec_extended_filter_;
}
 void Test::set_use_aec_extended_filter(bool value) {
  set_has_use_aec_extended_filter();
  use_aec_extended_filter_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.use_aec_extended_filter)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForOutputData(
    OutputData* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OutputData::kTestFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OutputData::OutputData()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:webrtc.audioproc.OutputData)
}

void OutputData::InitAsDefaultInstance() {
}

OutputData::OutputData(const OutputData& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:webrtc.audioproc.OutputData)
}

void OutputData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OutputData::~OutputData() {
  // @@protoc_insertion_point(destructor:webrtc.audioproc.OutputData)
  SharedDtor();
}

void OutputData::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OutputData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OutputData& OutputData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_unittest_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_unittest_2eproto();
#endif
  return *default_instance_;
}

OutputData* OutputData::default_instance_ = NULL;

OutputData* OutputData::New(::google::protobuf::Arena* arena) const {
  OutputData* n = new OutputData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OutputData::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.audioproc.OutputData)
  test_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool OutputData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForOutputData, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:webrtc.audioproc.OutputData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .webrtc.audioproc.Test test = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_test:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_test()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_test;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:webrtc.audioproc.OutputData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:webrtc.audioproc.OutputData)
  return false;
#undef DO_
}

void OutputData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:webrtc.audioproc.OutputData)
  // repeated .webrtc.audioproc.Test test = 1;
  for (unsigned int i = 0, n = this->test_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->test(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:webrtc.audioproc.OutputData)
}

int OutputData::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.audioproc.OutputData)
  int total_size = 0;

  // repeated .webrtc.audioproc.Test test = 1;
  total_size += 1 * this->test_size();
  for (int i = 0; i < this->test_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->test(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OutputData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OutputData*>(&from));
}

void OutputData::MergeFrom(const OutputData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:webrtc.audioproc.OutputData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  test_.MergeFrom(from.test_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void OutputData::CopyFrom(const OutputData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.audioproc.OutputData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutputData::IsInitialized() const {

  return true;
}

void OutputData::Swap(OutputData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OutputData::InternalSwap(OutputData* other) {
  test_.UnsafeArenaSwap(&other->test_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string OutputData::GetTypeName() const {
  return "webrtc.audioproc.OutputData";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OutputData

// repeated .webrtc.audioproc.Test test = 1;
int OutputData::test_size() const {
  return test_.size();
}
void OutputData::clear_test() {
  test_.Clear();
}
const ::webrtc::audioproc::Test& OutputData::test(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.OutputData.test)
  return test_.Get(index);
}
::webrtc::audioproc::Test* OutputData::mutable_test(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.OutputData.test)
  return test_.Mutable(index);
}
::webrtc::audioproc::Test* OutputData::add_test() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.OutputData.test)
  return test_.Add();
}
::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >*
OutputData::mutable_test() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.OutputData.test)
  return &test_;
}
const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >&
OutputData::test() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.OutputData.test)
  return test_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace audioproc
}  // namespace webrtc

// @@protoc_insertion_point(global_scope)
